{"ast":null,"code":"import { Chart } from \"chart.js\";\nimport { drag } from \"d3-drag\";\nimport { select } from \"d3-selection\";\nlet element, yAxisID, xAxisID, rAxisID, type, stacked, floatingBar, initValue, curDatasetIndex, curIndex, eventSettings;\nlet isDragging = false;\n\nfunction getSafe(func) {\n  try {\n    return func();\n  } catch (e) {\n    return \"\";\n  }\n}\n\nconst getElement = (e, chartInstance, callback) => {\n  element = chartInstance.getElementsAtEventForMode(e, \"nearest\", {\n    intersect: true\n  }, false)[0];\n  type = chartInstance.config.type;\n\n  if (element) {\n    let datasetIndex = element.datasetIndex;\n    let index = element.index; // save element settings\n\n    eventSettings = getSafe(() => chartInstance.config.options.plugins.tooltip.animation);\n    const dataset = chartInstance.data.datasets[datasetIndex];\n    const datasetMeta = chartInstance.getDatasetMeta(datasetIndex);\n    let curValue = dataset.data[index]; // get the id of the datasets scale\n\n    xAxisID = datasetMeta.xAxisID;\n    yAxisID = datasetMeta.yAxisID;\n    rAxisID = datasetMeta.rAxisID; // check if dragging the dataset or datapoint is prohibited\n\n    if (dataset.dragData === false || chartInstance.config.options.scales[xAxisID] && chartInstance.config.options.scales[xAxisID].dragData === false || chartInstance.config.options.scales[yAxisID] && chartInstance.config.options.scales[yAxisID].dragData === false || chartInstance.config.options.scales[rAxisID] && chartInstance.config.options.scales[rAxisID].rAxisID === false || dataset.data[element.index].dragData === false) {\n      element = null;\n      return;\n    }\n\n    if (type === \"bar\") {\n      stacked = chartInstance.config.options.scales[xAxisID].stacked; // if a bar has a data point that is an array of length 2, it's a floating bar\n\n      const samplePoint = chartInstance.data.datasets[0].data[0];\n      floatingBar = samplePoint !== null && Array.isArray(samplePoint) && samplePoint.length === 2;\n      let data = {};\n      let newPos = calcPosition(e, chartInstance, datasetIndex, index, data);\n      initValue = newPos - curValue;\n    } // disable the tooltip animation\n\n\n    if (chartInstance.config.options.plugins.dragData.showTooltip === undefined || chartInstance.config.options.plugins.dragData.showTooltip) {\n      if (!chartInstance.config.options.plugins.tooltip) chartInstance.config.options.plugins.tooltip = {};\n      chartInstance.config.options.plugins.tooltip.animation = false;\n    }\n\n    if (typeof callback === \"function\" && element) {\n      if (callback(e, datasetIndex, index, curValue) === false) {\n        element = null;\n      }\n    }\n  }\n};\n\nfunction roundValue(value, pos) {\n  if (!isNaN(pos)) {\n    return Math.round(value * Math.pow(10, pos)) / Math.pow(10, pos);\n  }\n\n  return value;\n}\n\nfunction calcRadar(e, chartInstance) {\n  let x, y, v;\n\n  if (e.touches) {\n    x = e.touches[0].clientX - chartInstance.canvas.getBoundingClientRect().left;\n    y = e.touches[0].clientY - chartInstance.canvas.getBoundingClientRect().top;\n  } else {\n    x = e.clientX - chartInstance.canvas.getBoundingClientRect().left;\n    y = e.clientY - chartInstance.canvas.getBoundingClientRect().top;\n  }\n\n  let rScale = chartInstance.scales[rAxisID];\n  let d = Math.sqrt(Math.pow(x - rScale.xCenter, 2) + Math.pow(y - rScale.yCenter, 2));\n  let scalingFactor = rScale.drawingArea / (rScale.max - rScale.min);\n\n  if (rScale.options.ticks.reverse) {\n    v = rScale.max - d / scalingFactor;\n  } else {\n    v = rScale.min + d / scalingFactor;\n  }\n\n  v = roundValue(v, chartInstance.config.options.plugins.dragData.round);\n  v = v > chartInstance.scales[rAxisID].max ? chartInstance.scales[rAxisID].max : v;\n  v = v < chartInstance.scales[rAxisID].min ? chartInstance.scales[rAxisID].min : v;\n  return v;\n}\n\nfunction calcPosition(e, chartInstance, datasetIndex, index, data) {\n  let x, y;\n  const dataPoint = chartInstance.data.datasets[datasetIndex].data[index];\n\n  if (e.touches) {\n    x = chartInstance.scales[xAxisID].getValueForPixel(e.touches[0].clientX - chartInstance.canvas.getBoundingClientRect().left);\n    y = chartInstance.scales[yAxisID].getValueForPixel(e.touches[0].clientY - chartInstance.canvas.getBoundingClientRect().top);\n  } else {\n    x = chartInstance.scales[xAxisID].getValueForPixel(e.clientX - chartInstance.canvas.getBoundingClientRect().left);\n    y = chartInstance.scales[yAxisID].getValueForPixel(e.clientY - chartInstance.canvas.getBoundingClientRect().top);\n  }\n\n  x = roundValue(x, chartInstance.config.options.plugins.dragData.round);\n  y = roundValue(y, chartInstance.config.options.plugins.dragData.round);\n  x = x > chartInstance.scales[xAxisID].max ? chartInstance.scales[xAxisID].max : x;\n  x = x < chartInstance.scales[xAxisID].min ? chartInstance.scales[xAxisID].min : x;\n  y = y > chartInstance.scales[yAxisID].max ? chartInstance.scales[yAxisID].max : y;\n  y = y < chartInstance.scales[yAxisID].min ? chartInstance.scales[yAxisID].min : y;\n\n  if (floatingBar) {\n    // x contains the new value for one end of the floating bar\n    // dataPoint contains the old interval [left, right] of the floating bar\n    // calculate difference between the new value and both sides\n    // the side with the smallest difference from the new value was the one that was dragged\n    // return an interval with new value on the dragged side and old value on the other side\n    let newVal; // choose the right variable based on the orientation of the graph(vertical, horizontal)\n\n    if (chartInstance.config.options.indexAxis === \"y\") {\n      newVal = x;\n    } else {\n      newVal = y;\n    }\n\n    const diffFromLeft = Math.abs(newVal - dataPoint[0]);\n    const diffFromRight = Math.abs(newVal - dataPoint[1]);\n\n    if (diffFromLeft <= diffFromRight) {\n      return [newVal, dataPoint[1]];\n    } else {\n      return [dataPoint[0], newVal];\n    }\n  }\n\n  if (dataPoint.x !== undefined && chartInstance.config.options.plugins.dragData.dragX) {\n    dataPoint.x = x;\n  }\n\n  if (dataPoint.y !== undefined) {\n    if (chartInstance.config.options.plugins.dragData.dragY !== false) {\n      dataPoint.y = y;\n    }\n\n    return dataPoint;\n  } else {\n    if (chartInstance.config.options.indexAxis === \"y\") {\n      return x;\n    } else {\n      return y;\n    }\n  }\n}\n\nconst updateData = (e, chartInstance, pluginOptions, callback) => {\n  if (element) {\n    curDatasetIndex = element.datasetIndex;\n    curIndex = element.index;\n    isDragging = true;\n    let dataPoint = chartInstance.data.datasets[curDatasetIndex].data[curIndex];\n\n    if (type === \"radar\" || type === \"polarArea\") {\n      dataPoint = calcRadar(e, chartInstance);\n    } else if (stacked) {\n      let cursorPos = calcPosition(e, chartInstance, curDatasetIndex, curIndex, dataPoint);\n      dataPoint = roundValue(cursorPos - initValue, pluginOptions.round);\n    } else if (floatingBar) {\n      dataPoint = calcPosition(e, chartInstance, curDatasetIndex, curIndex, dataPoint);\n    } else {\n      dataPoint = calcPosition(e, chartInstance, curDatasetIndex, curIndex, dataPoint);\n    }\n\n    if (!callback || typeof callback === \"function\" && callback(e, curDatasetIndex, curIndex, dataPoint) !== false) {\n      chartInstance.data.datasets[curDatasetIndex].data[curIndex] = dataPoint;\n      chartInstance.update(\"none\");\n    }\n  }\n}; // Update values to the nearest values\n\n\nfunction applyMagnet(chartInstance, i, j) {\n  const pluginOptions = chartInstance.config.options.plugins.dragData;\n\n  if (pluginOptions.magnet) {\n    const magnet = pluginOptions.magnet;\n\n    if (magnet.to && typeof magnet.to === \"function\") {\n      let data = chartInstance.data.datasets[i].data[j];\n      data = magnet.to(data);\n      chartInstance.data.datasets[i].data[j] = data;\n      chartInstance.update(\"none\");\n      return data;\n    }\n  } else {\n    return chartInstance.data.datasets[i].data[j];\n  }\n}\n\nconst dragEndCallback = (e, chartInstance, callback) => {\n  // eslint-disable-next-line no-unused-expressions\n  curDatasetIndex, curIndex = undefined;\n  isDragging = false; // re-enable the tooltip animation\n\n  if (chartInstance.config.options.plugins.tooltip) {\n    chartInstance.config.options.plugins.tooltip.animation = eventSettings;\n    chartInstance.update(\"none\");\n  } // chartInstance.update('none')\n\n\n  if (typeof callback === \"function\" && element) {\n    const datasetIndex = element.datasetIndex;\n    const index = element.index;\n    let value = applyMagnet(chartInstance, datasetIndex, index);\n    return callback(e, datasetIndex, index, value);\n  }\n};\n\nconst ChartJSdragDataPlugin = {\n  id: \"dragdata\",\n  afterInit: function (chartInstance) {\n    if (chartInstance.config.options.plugins && chartInstance.config.options.plugins.dragData) {\n      const pluginOptions = chartInstance.config.options.plugins.dragData;\n      select(chartInstance.canvas).call(drag().container(chartInstance.canvas).on(\"start\", e => getElement(e.sourceEvent, chartInstance, pluginOptions.onDragStart)).on(\"drag\", e => updateData(e.sourceEvent, chartInstance, pluginOptions, pluginOptions.onDrag)).on(\"end\", e => dragEndCallback(e.sourceEvent, chartInstance, pluginOptions.onDragEnd)));\n    }\n  },\n  beforeEvent: function (chart, args) {\n    if (isDragging) {\n      chart.tooltip.update();\n      return false;\n    }\n  }\n  /*\n  afterEvent: function (chart) { \n    if (!element) return    \n    if (isDragging) {\n      \n      chart.tooltip.setActiveElements([element],{\n        x: element.element.x,\n        y: element.element.y\n      })\n    }\n  }\n  */\n\n};\nChart.register(ChartJSdragDataPlugin);\nexport default ChartJSdragDataPlugin;","map":{"version":3,"sources":["/Users/max/Documents/GitHub/Projection/src/components/Chart/chartjs-plugin-dragdata.js"],"names":["Chart","drag","select","element","yAxisID","xAxisID","rAxisID","type","stacked","floatingBar","initValue","curDatasetIndex","curIndex","eventSettings","isDragging","getSafe","func","e","getElement","chartInstance","callback","getElementsAtEventForMode","intersect","config","datasetIndex","index","options","plugins","tooltip","animation","dataset","data","datasets","datasetMeta","getDatasetMeta","curValue","dragData","scales","samplePoint","Array","isArray","length","newPos","calcPosition","showTooltip","undefined","roundValue","value","pos","isNaN","Math","round","pow","calcRadar","x","y","v","touches","clientX","canvas","getBoundingClientRect","left","clientY","top","rScale","d","sqrt","xCenter","yCenter","scalingFactor","drawingArea","max","min","ticks","reverse","dataPoint","getValueForPixel","newVal","indexAxis","diffFromLeft","abs","diffFromRight","dragX","dragY","updateData","pluginOptions","cursorPos","update","applyMagnet","i","j","magnet","to","dragEndCallback","ChartJSdragDataPlugin","id","afterInit","call","container","on","sourceEvent","onDragStart","onDrag","onDragEnd","beforeEvent","chart","args","register"],"mappings":"AAAA,SAASA,KAAT,QAAsB,UAAtB;AACA,SAASC,IAAT,QAAqB,SAArB;AACA,SAASC,MAAT,QAAuB,cAAvB;AACA,IAAIC,OAAJ,EACEC,OADF,EAEEC,OAFF,EAGEC,OAHF,EAIEC,IAJF,EAKEC,OALF,EAMEC,WANF,EAOEC,SAPF,EAQEC,eARF,EASEC,QATF,EAUEC,aAVF;AAWA,IAAIC,UAAU,GAAG,KAAjB;;AAEA,SAASC,OAAT,CAAiBC,IAAjB,EAAuB;AACrB,MAAI;AACF,WAAOA,IAAI,EAAX;AACD,GAFD,CAEE,OAAOC,CAAP,EAAU;AACV,WAAO,EAAP;AACD;AACF;;AAED,MAAMC,UAAU,GAAG,CAACD,CAAD,EAAIE,aAAJ,EAAmBC,QAAnB,KAAgC;AACjDjB,EAAAA,OAAO,GAAGgB,aAAa,CAACE,yBAAd,CACRJ,CADQ,EAER,SAFQ,EAGR;AAAEK,IAAAA,SAAS,EAAE;AAAb,GAHQ,EAIR,KAJQ,EAKR,CALQ,CAAV;AAMAf,EAAAA,IAAI,GAAGY,aAAa,CAACI,MAAd,CAAqBhB,IAA5B;;AAEA,MAAIJ,OAAJ,EAAa;AACX,QAAIqB,YAAY,GAAGrB,OAAO,CAACqB,YAA3B;AACA,QAAIC,KAAK,GAAGtB,OAAO,CAACsB,KAApB,CAFW,CAGX;;AACAZ,IAAAA,aAAa,GAAGE,OAAO,CACrB,MAAMI,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,CAAqCC,OAArC,CAA6CC,SAD9B,CAAvB;AAIA,UAAMC,OAAO,GAAGX,aAAa,CAACY,IAAd,CAAmBC,QAAnB,CAA4BR,YAA5B,CAAhB;AACA,UAAMS,WAAW,GAAGd,aAAa,CAACe,cAAd,CAA6BV,YAA7B,CAApB;AACA,QAAIW,QAAQ,GAAGL,OAAO,CAACC,IAAR,CAAaN,KAAb,CAAf,CAVW,CAWX;;AACApB,IAAAA,OAAO,GAAG4B,WAAW,CAAC5B,OAAtB;AACAD,IAAAA,OAAO,GAAG6B,WAAW,CAAC7B,OAAtB;AACAE,IAAAA,OAAO,GAAG2B,WAAW,CAAC3B,OAAtB,CAdW,CAgBX;;AACA,QACEwB,OAAO,CAACM,QAAR,KAAqB,KAArB,IACCjB,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BW,MAA7B,CAAoChC,OAApC,KACCc,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BW,MAA7B,CAAoChC,OAApC,EAA6C+B,QAA7C,KAA0D,KAF5D,IAGCjB,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BW,MAA7B,CAAoCjC,OAApC,KACCe,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BW,MAA7B,CAAoCjC,OAApC,EAA6CgC,QAA7C,KAA0D,KAJ5D,IAKCjB,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BW,MAA7B,CAAoC/B,OAApC,KACCa,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BW,MAA7B,CAAoC/B,OAApC,EAA6CA,OAA7C,KAAyD,KAN3D,IAOAwB,OAAO,CAACC,IAAR,CAAa5B,OAAO,CAACsB,KAArB,EAA4BW,QAA5B,KAAyC,KAR3C,EASE;AACAjC,MAAAA,OAAO,GAAG,IAAV;AACA;AACD;;AAED,QAAII,IAAI,KAAK,KAAb,EAAoB;AAClBC,MAAAA,OAAO,GAAGW,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BW,MAA7B,CAAoChC,OAApC,EAA6CG,OAAvD,CADkB,CAGlB;;AACA,YAAM8B,WAAW,GAAGnB,aAAa,CAACY,IAAd,CAAmBC,QAAnB,CAA4B,CAA5B,EAA+BD,IAA/B,CAAoC,CAApC,CAApB;AACAtB,MAAAA,WAAW,GACT6B,WAAW,KAAK,IAAhB,IACAC,KAAK,CAACC,OAAN,CAAcF,WAAd,CADA,IAEAA,WAAW,CAACG,MAAZ,KAAuB,CAHzB;AAKA,UAAIV,IAAI,GAAG,EAAX;AACA,UAAIW,MAAM,GAAGC,YAAY,CAAC1B,CAAD,EAAIE,aAAJ,EAAmBK,YAAnB,EAAiCC,KAAjC,EAAwCM,IAAxC,CAAzB;AACArB,MAAAA,SAAS,GAAGgC,MAAM,GAAGP,QAArB;AACD,KA5CU,CA8CX;;;AACA,QACEhB,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,CAAqCS,QAArC,CAA8CQ,WAA9C,KAA8DC,SAA9D,IACA1B,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,CAAqCS,QAArC,CAA8CQ,WAFhD,EAGE;AACA,UAAI,CAACzB,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,CAAqCC,OAA1C,EACET,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,CAAqCC,OAArC,GAA+C,EAA/C;AACFT,MAAAA,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,CAAqCC,OAArC,CAA6CC,SAA7C,GAAyD,KAAzD;AACD;;AAED,QAAI,OAAOT,QAAP,KAAoB,UAApB,IAAkCjB,OAAtC,EAA+C;AAC7C,UAAIiB,QAAQ,CAACH,CAAD,EAAIO,YAAJ,EAAkBC,KAAlB,EAAyBU,QAAzB,CAAR,KAA+C,KAAnD,EAA0D;AACxDhC,QAAAA,OAAO,GAAG,IAAV;AACD;AACF;AACF;AACF,CAvED;;AAyEA,SAAS2C,UAAT,CAAoBC,KAApB,EAA2BC,GAA3B,EAAgC;AAC9B,MAAI,CAACC,KAAK,CAACD,GAAD,CAAV,EAAiB;AACf,WAAOE,IAAI,CAACC,KAAL,CAAWJ,KAAK,GAAGG,IAAI,CAACE,GAAL,CAAS,EAAT,EAAaJ,GAAb,CAAnB,IAAwCE,IAAI,CAACE,GAAL,CAAS,EAAT,EAAaJ,GAAb,CAA/C;AACD;;AACD,SAAOD,KAAP;AACD;;AAED,SAASM,SAAT,CAAmBpC,CAAnB,EAAsBE,aAAtB,EAAqC;AACnC,MAAImC,CAAJ,EAAOC,CAAP,EAAUC,CAAV;;AACA,MAAIvC,CAAC,CAACwC,OAAN,EAAe;AACbH,IAAAA,CAAC,GACCrC,CAAC,CAACwC,OAAF,CAAU,CAAV,EAAaC,OAAb,GAAuBvC,aAAa,CAACwC,MAAd,CAAqBC,qBAArB,GAA6CC,IADtE;AAEAN,IAAAA,CAAC,GAAGtC,CAAC,CAACwC,OAAF,CAAU,CAAV,EAAaK,OAAb,GAAuB3C,aAAa,CAACwC,MAAd,CAAqBC,qBAArB,GAA6CG,GAAxE;AACD,GAJD,MAIO;AACLT,IAAAA,CAAC,GAAGrC,CAAC,CAACyC,OAAF,GAAYvC,aAAa,CAACwC,MAAd,CAAqBC,qBAArB,GAA6CC,IAA7D;AACAN,IAAAA,CAAC,GAAGtC,CAAC,CAAC6C,OAAF,GAAY3C,aAAa,CAACwC,MAAd,CAAqBC,qBAArB,GAA6CG,GAA7D;AACD;;AACD,MAAIC,MAAM,GAAG7C,aAAa,CAACkB,MAAd,CAAqB/B,OAArB,CAAb;AACA,MAAI2D,CAAC,GAAGf,IAAI,CAACgB,IAAL,CACNhB,IAAI,CAACE,GAAL,CAASE,CAAC,GAAGU,MAAM,CAACG,OAApB,EAA6B,CAA7B,IAAkCjB,IAAI,CAACE,GAAL,CAASG,CAAC,GAAGS,MAAM,CAACI,OAApB,EAA6B,CAA7B,CAD5B,CAAR;AAGA,MAAIC,aAAa,GAAGL,MAAM,CAACM,WAAP,IAAsBN,MAAM,CAACO,GAAP,GAAaP,MAAM,CAACQ,GAA1C,CAApB;;AACA,MAAIR,MAAM,CAACtC,OAAP,CAAe+C,KAAf,CAAqBC,OAAzB,EAAkC;AAChClB,IAAAA,CAAC,GAAGQ,MAAM,CAACO,GAAP,GAAaN,CAAC,GAAGI,aAArB;AACD,GAFD,MAEO;AACLb,IAAAA,CAAC,GAAGQ,MAAM,CAACQ,GAAP,GAAaP,CAAC,GAAGI,aAArB;AACD;;AAEDb,EAAAA,CAAC,GAAGV,UAAU,CAACU,CAAD,EAAIrC,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,CAAqCS,QAArC,CAA8Ce,KAAlD,CAAd;AAEAK,EAAAA,CAAC,GACCA,CAAC,GAAGrC,aAAa,CAACkB,MAAd,CAAqB/B,OAArB,EAA8BiE,GAAlC,GACIpD,aAAa,CAACkB,MAAd,CAAqB/B,OAArB,EAA8BiE,GADlC,GAEIf,CAHN;AAIAA,EAAAA,CAAC,GACCA,CAAC,GAAGrC,aAAa,CAACkB,MAAd,CAAqB/B,OAArB,EAA8BkE,GAAlC,GACIrD,aAAa,CAACkB,MAAd,CAAqB/B,OAArB,EAA8BkE,GADlC,GAEIhB,CAHN;AAKA,SAAOA,CAAP;AACD;;AAED,SAASb,YAAT,CAAsB1B,CAAtB,EAAyBE,aAAzB,EAAwCK,YAAxC,EAAsDC,KAAtD,EAA6DM,IAA7D,EAAmE;AACjE,MAAIuB,CAAJ,EAAOC,CAAP;AACA,QAAMoB,SAAS,GAAGxD,aAAa,CAACY,IAAd,CAAmBC,QAAnB,CAA4BR,YAA5B,EAA0CO,IAA1C,CAA+CN,KAA/C,CAAlB;;AAEA,MAAIR,CAAC,CAACwC,OAAN,EAAe;AACbH,IAAAA,CAAC,GAAGnC,aAAa,CAACkB,MAAd,CAAqBhC,OAArB,EAA8BuE,gBAA9B,CACF3D,CAAC,CAACwC,OAAF,CAAU,CAAV,EAAaC,OAAb,GAAuBvC,aAAa,CAACwC,MAAd,CAAqBC,qBAArB,GAA6CC,IADlE,CAAJ;AAGAN,IAAAA,CAAC,GAAGpC,aAAa,CAACkB,MAAd,CAAqBjC,OAArB,EAA8BwE,gBAA9B,CACF3D,CAAC,CAACwC,OAAF,CAAU,CAAV,EAAaK,OAAb,GAAuB3C,aAAa,CAACwC,MAAd,CAAqBC,qBAArB,GAA6CG,GADlE,CAAJ;AAGD,GAPD,MAOO;AACLT,IAAAA,CAAC,GAAGnC,aAAa,CAACkB,MAAd,CAAqBhC,OAArB,EAA8BuE,gBAA9B,CACF3D,CAAC,CAACyC,OAAF,GAAYvC,aAAa,CAACwC,MAAd,CAAqBC,qBAArB,GAA6CC,IADvD,CAAJ;AAGAN,IAAAA,CAAC,GAAGpC,aAAa,CAACkB,MAAd,CAAqBjC,OAArB,EAA8BwE,gBAA9B,CACF3D,CAAC,CAAC6C,OAAF,GAAY3C,aAAa,CAACwC,MAAd,CAAqBC,qBAArB,GAA6CG,GADvD,CAAJ;AAGD;;AAEDT,EAAAA,CAAC,GAAGR,UAAU,CAACQ,CAAD,EAAInC,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,CAAqCS,QAArC,CAA8Ce,KAAlD,CAAd;AACAI,EAAAA,CAAC,GAAGT,UAAU,CAACS,CAAD,EAAIpC,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,CAAqCS,QAArC,CAA8Ce,KAAlD,CAAd;AAEAG,EAAAA,CAAC,GACCA,CAAC,GAAGnC,aAAa,CAACkB,MAAd,CAAqBhC,OAArB,EAA8BkE,GAAlC,GACIpD,aAAa,CAACkB,MAAd,CAAqBhC,OAArB,EAA8BkE,GADlC,GAEIjB,CAHN;AAIAA,EAAAA,CAAC,GACCA,CAAC,GAAGnC,aAAa,CAACkB,MAAd,CAAqBhC,OAArB,EAA8BmE,GAAlC,GACIrD,aAAa,CAACkB,MAAd,CAAqBhC,OAArB,EAA8BmE,GADlC,GAEIlB,CAHN;AAKAC,EAAAA,CAAC,GACCA,CAAC,GAAGpC,aAAa,CAACkB,MAAd,CAAqBjC,OAArB,EAA8BmE,GAAlC,GACIpD,aAAa,CAACkB,MAAd,CAAqBjC,OAArB,EAA8BmE,GADlC,GAEIhB,CAHN;AAIAA,EAAAA,CAAC,GACCA,CAAC,GAAGpC,aAAa,CAACkB,MAAd,CAAqBjC,OAArB,EAA8BoE,GAAlC,GACIrD,aAAa,CAACkB,MAAd,CAAqBjC,OAArB,EAA8BoE,GADlC,GAEIjB,CAHN;;AAKA,MAAI9C,WAAJ,EAAiB;AACf;AACA;AACA;AACA;AACA;AACA,QAAIoE,MAAJ,CANe,CAOf;;AACA,QAAI1D,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BoD,SAA7B,KAA2C,GAA/C,EAAoD;AAClDD,MAAAA,MAAM,GAAGvB,CAAT;AACD,KAFD,MAEO;AACLuB,MAAAA,MAAM,GAAGtB,CAAT;AACD;;AACD,UAAMwB,YAAY,GAAG7B,IAAI,CAAC8B,GAAL,CAASH,MAAM,GAAGF,SAAS,CAAC,CAAD,CAA3B,CAArB;AACA,UAAMM,aAAa,GAAG/B,IAAI,CAAC8B,GAAL,CAASH,MAAM,GAAGF,SAAS,CAAC,CAAD,CAA3B,CAAtB;;AAEA,QAAII,YAAY,IAAIE,aAApB,EAAmC;AACjC,aAAO,CAACJ,MAAD,EAASF,SAAS,CAAC,CAAD,CAAlB,CAAP;AACD,KAFD,MAEO;AACL,aAAO,CAACA,SAAS,CAAC,CAAD,CAAV,EAAeE,MAAf,CAAP;AACD;AACF;;AAED,MACEF,SAAS,CAACrB,CAAV,KAAgBT,SAAhB,IACA1B,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,CAAqCS,QAArC,CAA8C8C,KAFhD,EAGE;AACAP,IAAAA,SAAS,CAACrB,CAAV,GAAcA,CAAd;AACD;;AAED,MAAIqB,SAAS,CAACpB,CAAV,KAAgBV,SAApB,EAA+B;AAC7B,QAAI1B,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,CAAqCS,QAArC,CAA8C+C,KAA9C,KAAwD,KAA5D,EAAmE;AACjER,MAAAA,SAAS,CAACpB,CAAV,GAAcA,CAAd;AACD;;AACD,WAAOoB,SAAP;AACD,GALD,MAKO;AACL,QAAIxD,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BoD,SAA7B,KAA2C,GAA/C,EAAoD;AAClD,aAAOxB,CAAP;AACD,KAFD,MAEO;AACL,aAAOC,CAAP;AACD;AACF;AACF;;AAED,MAAM6B,UAAU,GAAG,CAACnE,CAAD,EAAIE,aAAJ,EAAmBkE,aAAnB,EAAkCjE,QAAlC,KAA+C;AAChE,MAAIjB,OAAJ,EAAa;AACXQ,IAAAA,eAAe,GAAGR,OAAO,CAACqB,YAA1B;AACAZ,IAAAA,QAAQ,GAAGT,OAAO,CAACsB,KAAnB;AAEAX,IAAAA,UAAU,GAAG,IAAb;AAEA,QAAI6D,SAAS,GAAGxD,aAAa,CAACY,IAAd,CAAmBC,QAAnB,CAA4BrB,eAA5B,EAA6CoB,IAA7C,CAAkDnB,QAAlD,CAAhB;;AAEA,QAAIL,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,WAAjC,EAA8C;AAC5CoE,MAAAA,SAAS,GAAGtB,SAAS,CAACpC,CAAD,EAAIE,aAAJ,CAArB;AACD,KAFD,MAEO,IAAIX,OAAJ,EAAa;AAClB,UAAI8E,SAAS,GAAG3C,YAAY,CAC1B1B,CAD0B,EAE1BE,aAF0B,EAG1BR,eAH0B,EAI1BC,QAJ0B,EAK1B+D,SAL0B,CAA5B;AAOAA,MAAAA,SAAS,GAAG7B,UAAU,CAACwC,SAAS,GAAG5E,SAAb,EAAwB2E,aAAa,CAAClC,KAAtC,CAAtB;AACD,KATM,MASA,IAAI1C,WAAJ,EAAiB;AACtBkE,MAAAA,SAAS,GAAGhC,YAAY,CACtB1B,CADsB,EAEtBE,aAFsB,EAGtBR,eAHsB,EAItBC,QAJsB,EAKtB+D,SALsB,CAAxB;AAOD,KARM,MAQA;AACLA,MAAAA,SAAS,GAAGhC,YAAY,CACtB1B,CADsB,EAEtBE,aAFsB,EAGtBR,eAHsB,EAItBC,QAJsB,EAKtB+D,SALsB,CAAxB;AAOD;;AAED,QACE,CAACvD,QAAD,IACC,OAAOA,QAAP,KAAoB,UAApB,IACCA,QAAQ,CAACH,CAAD,EAAIN,eAAJ,EAAqBC,QAArB,EAA+B+D,SAA/B,CAAR,KAAsD,KAH1D,EAIE;AACAxD,MAAAA,aAAa,CAACY,IAAd,CAAmBC,QAAnB,CAA4BrB,eAA5B,EAA6CoB,IAA7C,CAAkDnB,QAAlD,IAA8D+D,SAA9D;AACAxD,MAAAA,aAAa,CAACoE,MAAd,CAAqB,MAArB;AACD;AACF;AACF,CA/CD,C,CAiDA;;;AACA,SAASC,WAAT,CAAqBrE,aAArB,EAAoCsE,CAApC,EAAuCC,CAAvC,EAA0C;AACxC,QAAML,aAAa,GAAGlE,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,CAAqCS,QAA3D;;AACA,MAAIiD,aAAa,CAACM,MAAlB,EAA0B;AACxB,UAAMA,MAAM,GAAGN,aAAa,CAACM,MAA7B;;AACA,QAAIA,MAAM,CAACC,EAAP,IAAa,OAAOD,MAAM,CAACC,EAAd,KAAqB,UAAtC,EAAkD;AAChD,UAAI7D,IAAI,GAAGZ,aAAa,CAACY,IAAd,CAAmBC,QAAnB,CAA4ByD,CAA5B,EAA+B1D,IAA/B,CAAoC2D,CAApC,CAAX;AACA3D,MAAAA,IAAI,GAAG4D,MAAM,CAACC,EAAP,CAAU7D,IAAV,CAAP;AACAZ,MAAAA,aAAa,CAACY,IAAd,CAAmBC,QAAnB,CAA4ByD,CAA5B,EAA+B1D,IAA/B,CAAoC2D,CAApC,IAAyC3D,IAAzC;AACAZ,MAAAA,aAAa,CAACoE,MAAd,CAAqB,MAArB;AACA,aAAOxD,IAAP;AACD;AACF,GATD,MASO;AACL,WAAOZ,aAAa,CAACY,IAAd,CAAmBC,QAAnB,CAA4ByD,CAA5B,EAA+B1D,IAA/B,CAAoC2D,CAApC,CAAP;AACD;AACF;;AAED,MAAMG,eAAe,GAAG,CAAC5E,CAAD,EAAIE,aAAJ,EAAmBC,QAAnB,KAAgC;AACtD;AACAT,EAAAA,eAAe,EAAGC,QAAQ,GAAGiC,SAA7B;AACA/B,EAAAA,UAAU,GAAG,KAAb,CAHsD,CAItD;;AACA,MAAIK,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,CAAqCC,OAAzC,EAAkD;AAChDT,IAAAA,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,CAAqCC,OAArC,CAA6CC,SAA7C,GAAyDhB,aAAzD;AACAM,IAAAA,aAAa,CAACoE,MAAd,CAAqB,MAArB;AACD,GARqD,CAUtD;;;AACA,MAAI,OAAOnE,QAAP,KAAoB,UAApB,IAAkCjB,OAAtC,EAA+C;AAC7C,UAAMqB,YAAY,GAAGrB,OAAO,CAACqB,YAA7B;AACA,UAAMC,KAAK,GAAGtB,OAAO,CAACsB,KAAtB;AACA,QAAIsB,KAAK,GAAGyC,WAAW,CAACrE,aAAD,EAAgBK,YAAhB,EAA8BC,KAA9B,CAAvB;AACA,WAAOL,QAAQ,CAACH,CAAD,EAAIO,YAAJ,EAAkBC,KAAlB,EAAyBsB,KAAzB,CAAf;AACD;AACF,CAjBD;;AAmBA,MAAM+C,qBAAqB,GAAG;AAC5BC,EAAAA,EAAE,EAAE,UADwB;AAE5BC,EAAAA,SAAS,EAAE,UAAU7E,aAAV,EAAyB;AAClC,QACEA,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,IACAR,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,CAAqCS,QAFvC,EAGE;AACA,YAAMiD,aAAa,GAAGlE,aAAa,CAACI,MAAd,CAAqBG,OAArB,CAA6BC,OAA7B,CAAqCS,QAA3D;AACAlC,MAAAA,MAAM,CAACiB,aAAa,CAACwC,MAAf,CAAN,CAA6BsC,IAA7B,CACEhG,IAAI,GACDiG,SADH,CACa/E,aAAa,CAACwC,MAD3B,EAEGwC,EAFH,CAEM,OAFN,EAEgBlF,CAAD,IACXC,UAAU,CAACD,CAAC,CAACmF,WAAH,EAAgBjF,aAAhB,EAA+BkE,aAAa,CAACgB,WAA7C,CAHd,EAKGF,EALH,CAKM,MALN,EAKelF,CAAD,IACVmE,UAAU,CACRnE,CAAC,CAACmF,WADM,EAERjF,aAFQ,EAGRkE,aAHQ,EAIRA,aAAa,CAACiB,MAJN,CANd,EAaGH,EAbH,CAaM,KAbN,EAaclF,CAAD,IACT4E,eAAe,CACb5E,CAAC,CAACmF,WADW,EAEbjF,aAFa,EAGbkE,aAAa,CAACkB,SAHD,CAdnB,CADF;AAsBD;AACF,GA/B2B;AAgC5BC,EAAAA,WAAW,EAAE,UAAUC,KAAV,EAAiBC,IAAjB,EAAuB;AAClC,QAAI5F,UAAJ,EAAgB;AACd2F,MAAAA,KAAK,CAAC7E,OAAN,CAAc2D,MAAd;AACA,aAAO,KAAP;AACD;AACF;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAjD8B,CAA9B;AAmDAvF,KAAK,CAAC2G,QAAN,CAAeb,qBAAf;AAEA,eAAeA,qBAAf","sourcesContent":["import { Chart } from \"chart.js\";\nimport { drag } from \"d3-drag\";\nimport { select } from \"d3-selection\";\nlet element,\n  yAxisID,\n  xAxisID,\n  rAxisID,\n  type,\n  stacked,\n  floatingBar,\n  initValue,\n  curDatasetIndex,\n  curIndex,\n  eventSettings;\nlet isDragging = false;\n\nfunction getSafe(func) {\n  try {\n    return func();\n  } catch (e) {\n    return \"\";\n  }\n}\n\nconst getElement = (e, chartInstance, callback) => {\n  element = chartInstance.getElementsAtEventForMode(\n    e,\n    \"nearest\",\n    { intersect: true },\n    false\n  )[0];\n  type = chartInstance.config.type;\n\n  if (element) {\n    let datasetIndex = element.datasetIndex;\n    let index = element.index;\n    // save element settings\n    eventSettings = getSafe(\n      () => chartInstance.config.options.plugins.tooltip.animation\n    );\n\n    const dataset = chartInstance.data.datasets[datasetIndex];\n    const datasetMeta = chartInstance.getDatasetMeta(datasetIndex);\n    let curValue = dataset.data[index];\n    // get the id of the datasets scale\n    xAxisID = datasetMeta.xAxisID;\n    yAxisID = datasetMeta.yAxisID;\n    rAxisID = datasetMeta.rAxisID;\n\n    // check if dragging the dataset or datapoint is prohibited\n    if (\n      dataset.dragData === false ||\n      (chartInstance.config.options.scales[xAxisID] &&\n        chartInstance.config.options.scales[xAxisID].dragData === false) ||\n      (chartInstance.config.options.scales[yAxisID] &&\n        chartInstance.config.options.scales[yAxisID].dragData === false) ||\n      (chartInstance.config.options.scales[rAxisID] &&\n        chartInstance.config.options.scales[rAxisID].rAxisID === false) ||\n      dataset.data[element.index].dragData === false\n    ) {\n      element = null;\n      return;\n    }\n\n    if (type === \"bar\") {\n      stacked = chartInstance.config.options.scales[xAxisID].stacked;\n\n      // if a bar has a data point that is an array of length 2, it's a floating bar\n      const samplePoint = chartInstance.data.datasets[0].data[0];\n      floatingBar =\n        samplePoint !== null &&\n        Array.isArray(samplePoint) &&\n        samplePoint.length === 2;\n\n      let data = {};\n      let newPos = calcPosition(e, chartInstance, datasetIndex, index, data);\n      initValue = newPos - curValue;\n    }\n\n    // disable the tooltip animation\n    if (\n      chartInstance.config.options.plugins.dragData.showTooltip === undefined ||\n      chartInstance.config.options.plugins.dragData.showTooltip\n    ) {\n      if (!chartInstance.config.options.plugins.tooltip)\n        chartInstance.config.options.plugins.tooltip = {};\n      chartInstance.config.options.plugins.tooltip.animation = false;\n    }\n\n    if (typeof callback === \"function\" && element) {\n      if (callback(e, datasetIndex, index, curValue) === false) {\n        element = null;\n      }\n    }\n  }\n};\n\nfunction roundValue(value, pos) {\n  if (!isNaN(pos)) {\n    return Math.round(value * Math.pow(10, pos)) / Math.pow(10, pos);\n  }\n  return value;\n}\n\nfunction calcRadar(e, chartInstance) {\n  let x, y, v;\n  if (e.touches) {\n    x =\n      e.touches[0].clientX - chartInstance.canvas.getBoundingClientRect().left;\n    y = e.touches[0].clientY - chartInstance.canvas.getBoundingClientRect().top;\n  } else {\n    x = e.clientX - chartInstance.canvas.getBoundingClientRect().left;\n    y = e.clientY - chartInstance.canvas.getBoundingClientRect().top;\n  }\n  let rScale = chartInstance.scales[rAxisID];\n  let d = Math.sqrt(\n    Math.pow(x - rScale.xCenter, 2) + Math.pow(y - rScale.yCenter, 2)\n  );\n  let scalingFactor = rScale.drawingArea / (rScale.max - rScale.min);\n  if (rScale.options.ticks.reverse) {\n    v = rScale.max - d / scalingFactor;\n  } else {\n    v = rScale.min + d / scalingFactor;\n  }\n\n  v = roundValue(v, chartInstance.config.options.plugins.dragData.round);\n\n  v =\n    v > chartInstance.scales[rAxisID].max\n      ? chartInstance.scales[rAxisID].max\n      : v;\n  v =\n    v < chartInstance.scales[rAxisID].min\n      ? chartInstance.scales[rAxisID].min\n      : v;\n\n  return v;\n}\n\nfunction calcPosition(e, chartInstance, datasetIndex, index, data) {\n  let x, y;\n  const dataPoint = chartInstance.data.datasets[datasetIndex].data[index];\n\n  if (e.touches) {\n    x = chartInstance.scales[xAxisID].getValueForPixel(\n      e.touches[0].clientX - chartInstance.canvas.getBoundingClientRect().left\n    );\n    y = chartInstance.scales[yAxisID].getValueForPixel(\n      e.touches[0].clientY - chartInstance.canvas.getBoundingClientRect().top\n    );\n  } else {\n    x = chartInstance.scales[xAxisID].getValueForPixel(\n      e.clientX - chartInstance.canvas.getBoundingClientRect().left\n    );\n    y = chartInstance.scales[yAxisID].getValueForPixel(\n      e.clientY - chartInstance.canvas.getBoundingClientRect().top\n    );\n  }\n\n  x = roundValue(x, chartInstance.config.options.plugins.dragData.round);\n  y = roundValue(y, chartInstance.config.options.plugins.dragData.round);\n\n  x =\n    x > chartInstance.scales[xAxisID].max\n      ? chartInstance.scales[xAxisID].max\n      : x;\n  x =\n    x < chartInstance.scales[xAxisID].min\n      ? chartInstance.scales[xAxisID].min\n      : x;\n\n  y =\n    y > chartInstance.scales[yAxisID].max\n      ? chartInstance.scales[yAxisID].max\n      : y;\n  y =\n    y < chartInstance.scales[yAxisID].min\n      ? chartInstance.scales[yAxisID].min\n      : y;\n\n  if (floatingBar) {\n    // x contains the new value for one end of the floating bar\n    // dataPoint contains the old interval [left, right] of the floating bar\n    // calculate difference between the new value and both sides\n    // the side with the smallest difference from the new value was the one that was dragged\n    // return an interval with new value on the dragged side and old value on the other side\n    let newVal;\n    // choose the right variable based on the orientation of the graph(vertical, horizontal)\n    if (chartInstance.config.options.indexAxis === \"y\") {\n      newVal = x;\n    } else {\n      newVal = y;\n    }\n    const diffFromLeft = Math.abs(newVal - dataPoint[0]);\n    const diffFromRight = Math.abs(newVal - dataPoint[1]);\n\n    if (diffFromLeft <= diffFromRight) {\n      return [newVal, dataPoint[1]];\n    } else {\n      return [dataPoint[0], newVal];\n    }\n  }\n\n  if (\n    dataPoint.x !== undefined &&\n    chartInstance.config.options.plugins.dragData.dragX\n  ) {\n    dataPoint.x = x;\n  }\n\n  if (dataPoint.y !== undefined) {\n    if (chartInstance.config.options.plugins.dragData.dragY !== false) {\n      dataPoint.y = y;\n    }\n    return dataPoint;\n  } else {\n    if (chartInstance.config.options.indexAxis === \"y\") {\n      return x;\n    } else {\n      return y;\n    }\n  }\n}\n\nconst updateData = (e, chartInstance, pluginOptions, callback) => {\n  if (element) {\n    curDatasetIndex = element.datasetIndex;\n    curIndex = element.index;\n\n    isDragging = true;\n\n    let dataPoint = chartInstance.data.datasets[curDatasetIndex].data[curIndex];\n\n    if (type === \"radar\" || type === \"polarArea\") {\n      dataPoint = calcRadar(e, chartInstance);\n    } else if (stacked) {\n      let cursorPos = calcPosition(\n        e,\n        chartInstance,\n        curDatasetIndex,\n        curIndex,\n        dataPoint\n      );\n      dataPoint = roundValue(cursorPos - initValue, pluginOptions.round);\n    } else if (floatingBar) {\n      dataPoint = calcPosition(\n        e,\n        chartInstance,\n        curDatasetIndex,\n        curIndex,\n        dataPoint\n      );\n    } else {\n      dataPoint = calcPosition(\n        e,\n        chartInstance,\n        curDatasetIndex,\n        curIndex,\n        dataPoint\n      );\n    }\n\n    if (\n      !callback ||\n      (typeof callback === \"function\" &&\n        callback(e, curDatasetIndex, curIndex, dataPoint) !== false)\n    ) {\n      chartInstance.data.datasets[curDatasetIndex].data[curIndex] = dataPoint;\n      chartInstance.update(\"none\");\n    }\n  }\n};\n\n// Update values to the nearest values\nfunction applyMagnet(chartInstance, i, j) {\n  const pluginOptions = chartInstance.config.options.plugins.dragData;\n  if (pluginOptions.magnet) {\n    const magnet = pluginOptions.magnet;\n    if (magnet.to && typeof magnet.to === \"function\") {\n      let data = chartInstance.data.datasets[i].data[j];\n      data = magnet.to(data);\n      chartInstance.data.datasets[i].data[j] = data;\n      chartInstance.update(\"none\");\n      return data;\n    }\n  } else {\n    return chartInstance.data.datasets[i].data[j];\n  }\n}\n\nconst dragEndCallback = (e, chartInstance, callback) => {\n  // eslint-disable-next-line no-unused-expressions\n  curDatasetIndex, (curIndex = undefined);\n  isDragging = false;\n  // re-enable the tooltip animation\n  if (chartInstance.config.options.plugins.tooltip) {\n    chartInstance.config.options.plugins.tooltip.animation = eventSettings;\n    chartInstance.update(\"none\");\n  }\n\n  // chartInstance.update('none')\n  if (typeof callback === \"function\" && element) {\n    const datasetIndex = element.datasetIndex;\n    const index = element.index;\n    let value = applyMagnet(chartInstance, datasetIndex, index);\n    return callback(e, datasetIndex, index, value);\n  }\n};\n\nconst ChartJSdragDataPlugin = {\n  id: \"dragdata\",\n  afterInit: function (chartInstance) {\n    if (\n      chartInstance.config.options.plugins &&\n      chartInstance.config.options.plugins.dragData\n    ) {\n      const pluginOptions = chartInstance.config.options.plugins.dragData;\n      select(chartInstance.canvas).call(\n        drag()\n          .container(chartInstance.canvas)\n          .on(\"start\", (e) =>\n            getElement(e.sourceEvent, chartInstance, pluginOptions.onDragStart)\n          )\n          .on(\"drag\", (e) =>\n            updateData(\n              e.sourceEvent,\n              chartInstance,\n              pluginOptions,\n              pluginOptions.onDrag\n            )\n          )\n          .on(\"end\", (e) =>\n            dragEndCallback(\n              e.sourceEvent,\n              chartInstance,\n              pluginOptions.onDragEnd\n            )\n          )\n      );\n    }\n  },\n  beforeEvent: function (chart, args) {\n    if (isDragging) {\n      chart.tooltip.update();\n      return false;\n    }\n  }\n  /*\n  afterEvent: function (chart) { \n    if (!element) return    \n    if (isDragging) {\n      \n      chart.tooltip.setActiveElements([element],{\n        x: element.element.x,\n        y: element.element.y\n      })\n    }\n  }\n  */\n};\nChart.register(ChartJSdragDataPlugin);\n\nexport default ChartJSdragDataPlugin;\n"]},"metadata":{},"sourceType":"module"}