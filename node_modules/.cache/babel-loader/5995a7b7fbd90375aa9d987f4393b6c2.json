{"ast":null,"code":"/*!\n* chartjs-plugin-zoom v1.2.0\n* undefined\n * (c) 2016-2021 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, valueOrDefault, callback, sign } from 'chart.js/helpers';\n\nconst getModifierKey = opts => opts && opts.enabled && opts.modifierKey;\n\nconst keyPressed = (key, event) => key && event[key + 'Key'];\n\nconst keyNotPressed = (key, event) => key && !event[key + 'Key'];\n/**\n * @param {string|function} mode can be 'x', 'y' or 'xy'\n * @param {string} dir can be 'x' or 'y'\n * @param {import('chart.js').Chart} chart instance of the chart in question\n * @returns {boolean}\n */\n\n\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({\n      chart\n    }).indexOf(dir) !== -1;\n  }\n\n  return false;\n}\n/**\n * Debounces calling `fn` for `delay` ms\n * @param {function} fn - Function to call. No arguments are passed.\n * @param {number} delay - Delay in ms. 0 = immediate invocation.\n * @returns {function}\n */\n\n\nfunction debounce(fn, delay) {\n  let timeout;\n  return function () {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\n/** This function use for check what axis now under mouse cursor.\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale}\n */\n\n\nfunction getScaleUnderPoint(_ref, chart) {\n  let {\n    x,\n    y\n  } = _ref;\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n\n  return null;\n}\n/** This function return only one scale whose position is under mouse cursor and which direction is enabled.\n * If under mouse hasn't scale, then return all other scales which 'mode' is diffrent with overScaleMode.\n * So 'overScaleMode' works as a limiter to scale the user-selected scale (in 'mode') only when the cursor is under the scale,\n * and other directions in 'mode' works as before.\n * Example: mode = 'xy', overScaleMode = 'y' -> it's means 'x' - works as before, and 'y' only works for one scale when cursor is under it.\n * options.overScaleMode can be a function if user want zoom only one scale of many for example.\n * @param {string} mode - 'xy', 'x' or 'y'\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale[]}\n */\n\n\nfunction getEnabledScalesByPoint(mode, point, chart) {\n  const scale = getScaleUnderPoint(point, chart);\n\n  if (scale && directionEnabled(mode, scale.axis, chart)) {\n    return [scale];\n  }\n\n  const enabledScales = [];\n  each(chart.scales, function (scaleItem) {\n    if (!directionEnabled(mode, scaleItem.axis, chart)) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\n\nconst chartStates = new WeakMap();\n\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {}\n    };\n    chartStates.set(chart, state);\n  }\n\n  return state;\n}\n\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction zoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n  const centerPoint = scale.isHorizontal() ? center.x : center.y; // `scale.getValueForPixel()` can return a value less than the `scale.min` or\n  // greater than `scale.max` when `centerPoint` is outside chartArea.\n\n  const minPercent = Math.max(0, Math.min(1, (scale.getValueForPixel(centerPoint) - scale.min) / range || 0));\n  const maxPercent = 1 - minPercent;\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\n\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  let limit = scaleLimits[prop];\n\n  if (limit === 'original') {\n    const original = state.originalScaleLimits[scale.id][prop];\n    limit = valueOrDefault(original.options, original.scale);\n  }\n\n  return valueOrDefault(limit, fallback);\n}\n\nfunction updateRange(scale, _ref2, limits) {\n  let {\n    min,\n    max\n  } = _ref2;\n  let zoom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const state = getState(scale.chart);\n  const {\n    id,\n    axis,\n    options: scaleOpts\n  } = scale;\n  const scaleLimits = limits && (limits[id] || limits[axis]) || {};\n  const {\n    minRange = 0\n  } = scaleLimits;\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n  const cmin = Math.max(min, minLimit);\n  const cmax = Math.min(max, maxLimit);\n  const range = zoom ? Math.max(cmax - cmin, minRange) : scale.max - scale.min;\n\n  if (cmax - cmin !== range) {\n    if (minLimit > cmax - range) {\n      min = cmin;\n      max = cmin + range;\n    } else if (maxLimit < cmin + range) {\n      max = cmax;\n      min = cmax - range;\n    } else {\n      const offset = (range - cmax + cmin) / 2;\n      min = cmin - offset;\n      max = cmax + offset;\n    }\n  } else {\n    min = cmin;\n    max = cmax;\n  }\n\n  scaleOpts.min = min;\n  scaleOpts.max = max;\n  state.updatedScaleLimits[scale.id] = {\n    min,\n    max\n  }; // return true if the scale range is changed\n\n  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;\n}\n\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  const newRange = {\n    min: scale.min + delta.min,\n    max: scale.max - delta.max\n  };\n  return updateRange(scale, newRange, limits, true);\n}\n\nconst integerChange = v => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\n\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\n\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n\n  const newRange = {\n    min: scale.min + integerChange(delta.min),\n    max: scale.max - integerChange(delta.max)\n  };\n  return updateRange(scale, newRange, limits, true);\n}\n\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\n\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {\n    min,\n    max\n  } = scale; // The visible range. Ticks can be skipped, and thus not reliable.\n\n  const range = Math.max(max - min, 1); // How many pixels of delta is required before making a step. stepSize, but limited to max 1/10 of the scale length.\n\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n\n  return updateRange(scale, {\n    min,\n    max\n  }, limits) || applied;\n}\n\nconst OFFSETS = {\n  second: 500,\n  // 500 ms\n  minute: 30 * 1000,\n  // 30 s\n  hour: 30 * 60 * 1000,\n  // 30 m\n  day: 12 * 60 * 60 * 1000,\n  // 12 h\n  week: 3.5 * 24 * 60 * 60 * 1000,\n  // 3.5 d\n  month: 15 * 24 * 60 * 60 * 1000,\n  // 15 d\n  quarter: 60 * 24 * 60 * 60 * 1000,\n  // 60 d\n  year: 182 * 24 * 60 * 60 * 1000 // 182 d\n\n};\n\nfunction panNumericalScale(scale, delta, limits) {\n  let canZoom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const {\n    min: prevStart,\n    max: prevEnd,\n    options\n  } = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  const {\n    min: minLimit = -Infinity,\n    max: maxLimit = Infinity\n  } = canZoom && limits && limits[scale.axis] || {};\n\n  if (isNaN(newMin) || isNaN(newMax) || newMin < minLimit || newMax > maxLimit) {\n    // At limit: No change but return true to indicate no need to store the delta.\n    // NaN can happen for 0-dimension scales (either because they were configured\n    // with min === max or because the chart has 0 plottable area).\n    return true;\n  }\n\n  return updateRange(scale, {\n    min: newMin,\n    max: newMax\n  }, limits, canZoom);\n}\n\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\n\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale\n};\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale\n};\n\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  const {\n    id,\n    options: {\n      min,\n      max\n    }\n  } = scale;\n\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n\n  const previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\n\nfunction removeMissingScales(limits, scales) {\n  each(limits, (opt, key) => {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\n\nfunction storeOriginalScaleLimits(chart, state) {\n  const {\n    scales\n  } = chart;\n  const {\n    originalScaleLimits,\n    updatedScaleLimits\n  } = state;\n  each(scales, function (scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {\n          scale: scale.min,\n          options: scale.options.min\n        },\n        max: {\n          scale: scale.max,\n          options: scale.options.max\n        }\n      };\n    }\n  });\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\n\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\n\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2\n  };\n}\n/**\n * @param chart The chart instance\n * @param {number | {x?: number, y?: number, focalPoint?: {x: number, y: number}}} amount The zoom percentage or percentages and focal point\n * @param {string} [transition] Which transition mode to use. Defaults to 'none'\n */\n\n\nfunction zoom(chart, amount) {\n  let transition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'none';\n  const {\n    x = 1,\n    y = 1,\n    focalPoint = getCenter(chart)\n  } = typeof amount === 'number' ? {\n    x: amount,\n    y: amount\n  } : amount;\n  const state = getState(chart);\n  const {\n    options: {\n      limits,\n      zoom: zoomOptions\n    }\n  } = state;\n  const {\n    mode = 'xy',\n    overScaleMode\n  } = zoomOptions || {};\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 1 && directionEnabled(mode, 'x', chart);\n  const yEnabled = y !== 1 && directionEnabled(mode, 'y', chart);\n  const enabledScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, focalPoint, chart);\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart\n  }]);\n}\n\nfunction getRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\n\nfunction zoomRect(chart, p0, p1) {\n  let transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n  const state = getState(chart);\n  const {\n    options: {\n      limits,\n      zoom: zoomOptions\n    }\n  } = state;\n  const {\n    mode = 'xy'\n  } = zoomOptions;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  each(chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      updateRange(scale, getRange(scale, p0.x, p1.x), limits, true);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      updateRange(scale, getRange(scale, p0.y, p1.y), limits, true);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart\n  }]);\n}\n\nfunction zoomScale(chart, scaleId, range) {\n  let transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n  storeOriginalScaleLimits(chart, getState(chart));\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n}\n\nfunction resetZoom(chart) {\n  let transition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';\n  const state = getState(chart);\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state);\n  each(chart.scales, function (scale) {\n    const scaleOptions = scale.options;\n\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n  });\n  chart.update(transition);\n  callback(state.options.zoom.onZoomComplete, [{\n    chart\n  }]);\n}\n\nfunction getOriginalRange(state, scaleId) {\n  const original = state.originalScaleLimits[scaleId];\n\n  if (!original) {\n    return;\n  }\n\n  const {\n    min,\n    max\n  } = original;\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\n}\n\nfunction getZoomLevel(chart) {\n  const state = getState(chart);\n  let min = 1;\n  let max = 1;\n  each(chart.scales, function (scale) {\n    const origRange = getOriginalRange(state, scale.id);\n\n    if (origRange) {\n      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\n\nfunction panScale(scale, delta, limits, state) {\n  const {\n    panDelta\n  } = state; // Add possible cumulative delta from previous pan attempts where scale did not change\n\n  const storedDelta = panDelta[scale.id] || 0;\n\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n\n  const fn = panFunctions[scale.type] || panFunctions.default;\n\n  if (callback(fn, [scale, delta, limits])) {\n    // The scale changed, reset cumulative delta\n    panDelta[scale.id] = 0;\n  } else {\n    // The scale did not change, store cumulative delta\n    panDelta[scale.id] = delta;\n  }\n}\n\nfunction pan(chart, delta, enabledScales) {\n  let transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n  const {\n    x = 0,\n    y = 0\n  } = typeof delta === 'number' ? {\n    x: delta,\n    y: delta\n  } : delta;\n  const state = getState(chart);\n  const {\n    options: {\n      pan: panOptions,\n      limits\n    }\n  } = state;\n  const {\n    mode = 'xy',\n    onPan\n  } = panOptions || {};\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 0 && directionEnabled(mode, 'x', chart);\n  const yEnabled = y !== 0 && directionEnabled(mode, 'y', chart);\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n  chart.update(transition);\n  callback(onPan, [{\n    chart\n  }]);\n}\n\nfunction getInitialScaleBounds(chart) {\n  const state = getState(chart);\n  const scaleBounds = {};\n\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {\n      min,\n      max\n    } = state.originalScaleLimits[scaleId] || {\n      min: {},\n      max: {}\n    };\n    scaleBounds[scaleId] = {\n      min: min.scale,\n      max: max.scale\n    };\n  }\n\n  return scaleBounds;\n}\n\nfunction isZoomedOrPanned(chart) {\n  const scaleBounds = getInitialScaleBounds(chart);\n\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {\n      min: originalMin,\n      max: originalMax\n    } = scaleBounds[scaleId];\n\n    if (chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n\n    if (chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction removeHandler(chart, type) {\n  const {\n    handlers\n  } = getState(chart);\n  const handler = handlers[type];\n\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\n\nfunction addHandler(chart, target, type, handler) {\n  const {\n    handlers,\n    options\n  } = getState(chart);\n  removeHandler(chart, type);\n\n  handlers[type] = event => handler(chart, event, options);\n\n  handlers[type].target = target;\n  target.addEventListener(type, handlers[type]);\n}\n\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\n\nfunction zoomStart(chart, event, zoomOptions) {\n  const {\n    onZoomStart,\n    onZoomRejected\n  } = zoomOptions;\n\n  if (onZoomStart) {\n    const {\n      left: offsetX,\n      top: offsetY\n    } = event.target.getBoundingClientRect();\n    const point = {\n      x: event.clientX - offsetX,\n      y: event.clientY - offsetY\n    };\n\n    if (callback(onZoomStart, [{\n      chart,\n      event,\n      point\n    }]) === false) {\n      callback(onZoomRejected, [{\n        chart,\n        event\n      }]);\n      return false;\n    }\n  }\n}\n\nfunction mouseDown(chart, event) {\n  const state = getState(chart);\n  const {\n    pan: panOptions,\n    zoom: zoomOptions = {}\n  } = state.options;\n\n  if (keyPressed(getModifierKey(panOptions), event) || keyNotPressed(getModifierKey(zoomOptions.drag), event)) {\n    return callback(zoomOptions.onZoomRejected, [{\n      chart,\n      event\n    }]);\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n\n  state.dragStart = event;\n  addHandler(chart, chart.canvas, 'mousemove', mouseMove);\n}\n\nfunction computeDragRect(chart, mode, beginPoint, endPoint) {\n  const {\n    left: offsetX,\n    top: offsetY\n  } = beginPoint.target.getBoundingClientRect();\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  let {\n    top,\n    left,\n    right,\n    bottom,\n    width: chartWidth,\n    height: chartHeight\n  } = chart.chartArea;\n\n  if (xEnabled) {\n    left = Math.min(beginPoint.clientX, endPoint.clientX) - offsetX;\n    right = Math.max(beginPoint.clientX, endPoint.clientX) - offsetX;\n  }\n\n  if (yEnabled) {\n    top = Math.min(beginPoint.clientY, endPoint.clientY) - offsetY;\n    bottom = Math.max(beginPoint.clientY, endPoint.clientY) - offsetY;\n  }\n\n  const width = right - left;\n  const height = bottom - top;\n  return {\n    left,\n    top,\n    right,\n    bottom,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + (chartWidth - width) / chartWidth : 1,\n    zoomY: yEnabled && height ? 1 + (chartHeight - height) / chartHeight : 1\n  };\n}\n\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n\n  if (!state.dragStart) {\n    return;\n  }\n\n  removeHandler(chart, 'mousemove');\n  const {\n    mode,\n    onZoomComplete,\n    drag: {\n      threshold = 0\n    }\n  } = state.options.zoom;\n  const rect = computeDragRect(chart, mode, state.dragStart, event);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY); // Remove drag start and end before chart update to stop drawing selected area\n\n  state.dragStart = state.dragEnd = null;\n\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n\n  zoomRect(chart, {\n    x: rect.left,\n    y: rect.top\n  }, {\n    x: rect.right,\n    y: rect.bottom\n  }, 'zoom');\n  setTimeout(() => state.dragging = false, 500);\n  callback(onZoomComplete, [{\n    chart\n  }]);\n}\n\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  // Before preventDefault, check if the modifier key required and pressed\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    callback(zoomOptions.onZoomRejected, [{\n      chart,\n      event\n    }]);\n    return;\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  } // Prevent the event from triggering the default behavior (eg. Content scrolling).\n\n\n  if (event.cancelable) {\n    event.preventDefault();\n  } // Firefox always fires the wheel event twice:\n  // First without the delta and right after that once with the delta properties.\n\n\n  if (event.deltaY === undefined) {\n    return;\n  }\n\n  return true;\n}\n\nfunction wheel(chart, event) {\n  const {\n    handlers: {\n      onZoomComplete\n    },\n    options: {\n      zoom: zoomOptions\n    }\n  } = getState(chart);\n\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n\n  const rect = event.target.getBoundingClientRect();\n  const speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);\n  const amount = {\n    x: speed,\n    y: speed,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n  zoom(chart, amount);\n\n  if (onZoomComplete) {\n    onZoomComplete();\n  }\n}\n\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => callback(handler, [{\n      chart\n    }]), delay);\n  }\n}\n\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {\n    wheel: wheelOptions,\n    drag: dragOptions,\n    onZoomComplete\n  } = options.zoom; // Install listeners. Do this dynamically based on options so that we can turn zoom on and off\n  // We also want to make sure listeners aren't always on. E.g. if you're scrolling down a page\n  // and the mouse goes over a chart you don't want it intercepted unless the plugin is enabled\n\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n  }\n}\n\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n}\n\nfunction createEnabler(chart, state) {\n  return function (recognizer, event) {\n    const {\n      pan: panOptions,\n      zoom: zoomOptions = {}\n    } = state.options;\n\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n\n    const srcEvent = event && event.srcEvent;\n\n    if (!srcEvent) {\n      // Sometimes Hammer queries this with a null event.\n      return true;\n    }\n\n    if (!state.panning && event.pointerType === 'mouse' && (keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))) {\n      callback(panOptions.onPanRejected, [{\n        chart,\n        event\n      }]);\n      return false;\n    }\n\n    return true;\n  };\n}\n\nfunction pinchAxes(p0, p1) {\n  // fingers position difference\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY); // diagonal fingers will change both (xy) axes\n\n  const p = pinchX / pinchY;\n  let x, y;\n\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n\n  return {\n    x,\n    y\n  };\n}\n\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {\n      center,\n      pointers\n    } = e; // Hammer reports the total scaling. We need the incremental amount\n\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n    zoom(chart, amount); // Keep track of overall scale\n\n    state.scale = e.scale;\n  }\n}\n\nfunction startPinch(chart, state) {\n  if (state.options.zoom.pinch.enabled) {\n    state.scale = 1;\n  }\n}\n\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null; // reset\n\n    callback(state.options.zoom.onZoomComplete, [{\n      chart\n    }]);\n  }\n}\n\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n\n  if (delta) {\n    state.panning = true;\n    pan(chart, {\n      x: e.deltaX - delta.x,\n      y: e.deltaY - delta.y\n    }, state.panScales);\n    state.delta = {\n      x: e.deltaX,\n      y: e.deltaY\n    };\n  }\n}\n\nfunction startPan(chart, state, event) {\n  const {\n    enabled,\n    overScaleMode,\n    onPanStart,\n    onPanRejected\n  } = state.options.pan;\n\n  if (!enabled) {\n    return;\n  }\n\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n\n  if (callback(onPanStart, [{\n    chart,\n    event,\n    point\n  }]) === false) {\n    return callback(onPanRejected, [{\n      chart,\n      event\n    }]);\n  }\n\n  state.panScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, point, chart);\n  state.delta = {\n    x: 0,\n    y: 0\n  };\n  clearTimeout(state.panEndTimeout);\n  handlePan(chart, state, event);\n}\n\nfunction endPan(chart, state) {\n  state.delta = null;\n\n  if (state.panning) {\n    state.panEndTimeout = setTimeout(() => state.panning = false, 500);\n    callback(state.options.pan.onPanComplete, [{\n      chart\n    }]);\n  }\n}\n\nconst hammers = new WeakMap();\n\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {\n    pan: panOptions,\n    zoom: zoomOptions\n  } = options;\n  const mc = new Hammer.Manager(canvas);\n\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', () => startPinch(chart, state));\n    mc.on('pinch', e => handlePinch(chart, state, e));\n    mc.on('pinchend', e => endPinch(chart, state, e));\n  }\n\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', e => startPan(chart, state, e));\n    mc.on('panmove', e => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n\n  hammers.set(chart, mc);\n}\n\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\n\nvar version = \"1.2.0\";\nvar plugin = {\n  id: 'zoom',\n  version,\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy'\n    }\n  },\n  start: function (chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n\n    chart.resetZoom = transition => resetZoom(chart, transition);\n\n    chart.getZoomLevel = () => getZoomLevel(chart);\n\n    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);\n\n    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);\n  },\n\n  beforeEvent(chart) {\n    const state = getState(chart);\n\n    if (state.panning || state.dragging) {\n      // cancel any event handling while panning or dragging\n      return false;\n    }\n  },\n\n  beforeUpdate: function (chart, args, options) {\n    const state = getState(chart);\n    state.options = options;\n    addListeners(chart, options);\n  },\n  beforeDatasetsDraw: function (chart, args, options) {\n    const {\n      dragStart,\n      dragEnd\n    } = getState(chart);\n\n    if (dragEnd) {\n      const {\n        left,\n        top,\n        width,\n        height\n      } = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd);\n      const dragOptions = options.zoom.drag;\n      const ctx = chart.ctx;\n      ctx.save();\n      ctx.beginPath();\n      ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n      ctx.fillRect(left, top, width, height);\n\n      if (dragOptions.borderWidth > 0) {\n        ctx.lineWidth = dragOptions.borderWidth;\n        ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n        ctx.strokeRect(left, top, width, height);\n      }\n\n      ctx.restore();\n    }\n  },\n  stop: function (chart) {\n    removeListeners(chart);\n\n    if (Hammer) {\n      stopHammer(chart);\n    }\n\n    removeState(chart);\n  },\n  panFunctions,\n  zoomFunctions\n};\nexport { plugin as default, pan, resetZoom, zoom, zoomScale };","map":{"version":3,"sources":["/Users/max/Documents/GitHub/Projection/node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js"],"names":["Hammer","each","valueOrDefault","callback","sign","getModifierKey","opts","enabled","modifierKey","keyPressed","key","event","keyNotPressed","directionEnabled","mode","dir","chart","undefined","indexOf","debounce","fn","delay","timeout","clearTimeout","setTimeout","getScaleUnderPoint","x","y","scales","scaleIds","Object","keys","i","length","scale","top","bottom","left","right","getEnabledScalesByPoint","point","axis","enabledScales","scaleItem","push","chartStates","WeakMap","getState","state","get","originalScaleLimits","updatedScaleLimits","handlers","panDelta","set","removeState","delete","zoomDelta","zoom","center","range","max","min","newRange","centerPoint","isHorizontal","minPercent","Math","getValueForPixel","maxPercent","getLimit","scaleLimits","prop","fallback","limit","original","id","options","updateRange","limits","scaleOpts","minRange","minLimit","Infinity","maxLimit","cmin","cmax","offset","parse","zoomNumericalScale","delta","integerChange","v","isNaN","round","existCategoryFromMaxZoom","labels","getLabels","maxIndex","zoomCategoryScale","scaleLength","width","height","panCategoryScale","lastLabelIndex","stepDelta","stepSize","abs","applied","OFFSETS","second","minute","hour","day","week","month","quarter","year","panNumericalScale","canZoom","prevStart","prevEnd","time","newMin","getPixelForValue","newMax","panNonLinearScale","zoomFunctions","category","default","panFunctions","logarithmic","timeseries","shouldUpdateScaleLimits","previous","removeMissingScales","opt","storeOriginalScaleLimits","doZoom","amount","type","getCenter","ca","chartArea","transition","focalPoint","zoomOptions","overScaleMode","xEnabled","yEnabled","update","onZoom","getRange","pixel0","pixel1","v0","v1","zoomRect","p0","p1","zoomScale","scaleId","resetZoom","scaleOptions","onZoomComplete","getOriginalRange","getZoomLevel","origRange","level","panScale","storedDelta","pan","panOptions","onPan","getInitialScaleBounds","scaleBounds","isZoomedOrPanned","originalMin","originalMax","removeHandler","handler","target","removeEventListener","addHandler","addEventListener","mouseMove","dragStart","dragging","dragEnd","zoomStart","onZoomStart","onZoomRejected","offsetX","offsetY","getBoundingClientRect","clientX","clientY","mouseDown","drag","canvas","computeDragRect","beginPoint","endPoint","chartWidth","chartHeight","zoomX","zoomY","mouseUp","threshold","rect","distanceX","distanceY","distance","sqrt","wheelPreconditions","wheel","cancelable","preventDefault","deltaY","speed","addDebouncedHandler","name","addListeners","wheelOptions","dragOptions","ownerDocument","removeListeners","createEnabler","recognizer","srcEvent","panning","pointerType","onPanRejected","pinchAxes","pinchX","pinchY","p","handlePinch","e","pointers","zoomPercent","pinch","startPinch","endPinch","handlePan","deltaX","panScales","startPan","onPanStart","panEndTimeout","endPan","onPanComplete","hammers","startHammer","mc","Manager","add","Pinch","on","Pan","enable","stopHammer","remove","destroy","version","plugin","defaults","start","_args","prototype","hasOwnProperty","call","console","warn","args","beforeEvent","beforeUpdate","beforeDatasetsDraw","ctx","save","beginPath","fillStyle","backgroundColor","fillRect","borderWidth","lineWidth","strokeStyle","borderColor","strokeRect","restore","stop"],"mappings":"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","sourcesContent":["/*!\n* chartjs-plugin-zoom v1.2.0\n* undefined\n * (c) 2016-2021 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, valueOrDefault, callback, sign } from 'chart.js/helpers';\n\nconst getModifierKey = opts => opts && opts.enabled && opts.modifierKey;\nconst keyPressed = (key, event) => key && event[key + 'Key'];\nconst keyNotPressed = (key, event) => key && !event[key + 'Key'];\n\n/**\n * @param {string|function} mode can be 'x', 'y' or 'xy'\n * @param {string} dir can be 'x' or 'y'\n * @param {import('chart.js').Chart} chart instance of the chart in question\n * @returns {boolean}\n */\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({chart}).indexOf(dir) !== -1;\n  }\n\n  return false;\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n * @param {function} fn - Function to call. No arguments are passed.\n * @param {number} delay - Delay in ms. 0 = immediate invocation.\n * @returns {function}\n */\nfunction debounce(fn, delay) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\n\n/** This function use for check what axis now under mouse cursor.\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale}\n */\nfunction getScaleUnderPoint({x, y}, chart) {\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n  return null;\n}\n\n/** This function return only one scale whose position is under mouse cursor and which direction is enabled.\n * If under mouse hasn't scale, then return all other scales which 'mode' is diffrent with overScaleMode.\n * So 'overScaleMode' works as a limiter to scale the user-selected scale (in 'mode') only when the cursor is under the scale,\n * and other directions in 'mode' works as before.\n * Example: mode = 'xy', overScaleMode = 'y' -> it's means 'x' - works as before, and 'y' only works for one scale when cursor is under it.\n * options.overScaleMode can be a function if user want zoom only one scale of many for example.\n * @param {string} mode - 'xy', 'x' or 'y'\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale[]}\n */\nfunction getEnabledScalesByPoint(mode, point, chart) {\n  const scale = getScaleUnderPoint(point, chart);\n\n  if (scale && directionEnabled(mode, scale.axis, chart)) {\n    return [scale];\n  }\n\n  const enabledScales = [];\n  each(chart.scales, function(scaleItem) {\n    if (!directionEnabled(mode, scaleItem.axis, chart)) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\n\nconst chartStates = new WeakMap();\n\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {}\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\n\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction zoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n\n  const centerPoint = scale.isHorizontal() ? center.x : center.y;\n  // `scale.getValueForPixel()` can return a value less than the `scale.min` or\n  // greater than `scale.max` when `centerPoint` is outside chartArea.\n  const minPercent = Math.max(0, Math.min(1,\n    (scale.getValueForPixel(centerPoint) - scale.min) / range || 0\n  ));\n\n  const maxPercent = 1 - minPercent;\n\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\n\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  let limit = scaleLimits[prop];\n  if (limit === 'original') {\n    const original = state.originalScaleLimits[scale.id][prop];\n    limit = valueOrDefault(original.options, original.scale);\n  }\n  return valueOrDefault(limit, fallback);\n}\n\nfunction updateRange(scale, {min, max}, limits, zoom = false) {\n  const state = getState(scale.chart);\n  const {id, axis, options: scaleOpts} = scale;\n\n  const scaleLimits = limits && (limits[id] || limits[axis]) || {};\n  const {minRange = 0} = scaleLimits;\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n\n  const cmin = Math.max(min, minLimit);\n  const cmax = Math.min(max, maxLimit);\n  const range = zoom ? Math.max(cmax - cmin, minRange) : scale.max - scale.min;\n  if (cmax - cmin !== range) {\n    if (minLimit > cmax - range) {\n      min = cmin;\n      max = cmin + range;\n    } else if (maxLimit < cmin + range) {\n      max = cmax;\n      min = cmax - range;\n    } else {\n      const offset = (range - cmax + cmin) / 2;\n      min = cmin - offset;\n      max = cmax + offset;\n    }\n  } else {\n    min = cmin;\n    max = cmax;\n  }\n  scaleOpts.min = min;\n  scaleOpts.max = max;\n\n  state.updatedScaleLimits[scale.id] = {min, max};\n\n  // return true if the scale range is changed\n  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;\n}\n\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  const newRange = {min: scale.min + delta.min, max: scale.max - delta.max};\n  return updateRange(scale, newRange, limits, true);\n}\n\nconst integerChange = (v) => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\n\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\n\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n  const newRange = {min: scale.min + integerChange(delta.min), max: scale.max - integerChange(delta.max)};\n  return updateRange(scale, newRange, limits, true);\n}\n\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\n\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {min, max} = scale;\n  // The visible range. Ticks can be skipped, and thus not reliable.\n  const range = Math.max(max - min, 1);\n  // How many pixels of delta is required before making a step. stepSize, but limited to max 1/10 of the scale length.\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n\n  return updateRange(scale, {min, max}, limits) || applied;\n}\n\nconst OFFSETS = {\n  second: 500, // 500 ms\n  minute: 30 * 1000, // 30 s\n  hour: 30 * 60 * 1000, // 30 m\n  day: 12 * 60 * 60 * 1000, // 12 h\n  week: 3.5 * 24 * 60 * 60 * 1000, // 3.5 d\n  month: 15 * 24 * 60 * 60 * 1000, // 15 d\n  quarter: 60 * 24 * 60 * 60 * 1000, // 60 d\n  year: 182 * 24 * 60 * 60 * 1000 // 182 d\n};\n\nfunction panNumericalScale(scale, delta, limits, canZoom = false) {\n  const {min: prevStart, max: prevEnd, options} = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  const {min: minLimit = -Infinity, max: maxLimit = Infinity} = canZoom && limits && limits[scale.axis] || {};\n  if (isNaN(newMin) || isNaN(newMax) || newMin < minLimit || newMax > maxLimit) {\n    // At limit: No change but return true to indicate no need to store the delta.\n    // NaN can happen for 0-dimension scales (either because they were configured\n    // with min === max or because the chart has 0 plottable area).\n    return true;\n  }\n  return updateRange(scale, {min: newMin, max: newMax}, limits, canZoom);\n}\n\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\n\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale,\n};\n\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale,\n};\n\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  const {id, options: {min, max}} = scale;\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n  const previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\n\nfunction removeMissingScales(limits, scales) {\n  each(limits, (opt, key) => {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\n\nfunction storeOriginalScaleLimits(chart, state) {\n  const {scales} = chart;\n  const {originalScaleLimits, updatedScaleLimits} = state;\n\n  each(scales, function(scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {scale: scale.min, options: scale.options.min},\n        max: {scale: scale.max, options: scale.options.max},\n      };\n    }\n  });\n\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\n\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\n\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2,\n  };\n}\n\n/**\n * @param chart The chart instance\n * @param {number | {x?: number, y?: number, focalPoint?: {x: number, y: number}}} amount The zoom percentage or percentages and focal point\n * @param {string} [transition] Which transition mode to use. Defaults to 'none'\n */\nfunction zoom(chart, amount, transition = 'none') {\n  const {x = 1, y = 1, focalPoint = getCenter(chart)} = typeof amount === 'number' ? {x: amount, y: amount} : amount;\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n  const {mode = 'xy', overScaleMode} = zoomOptions || {};\n\n  storeOriginalScaleLimits(chart, state);\n\n  const xEnabled = x !== 1 && directionEnabled(mode, 'x', chart);\n  const yEnabled = y !== 1 && directionEnabled(mode, 'y', chart);\n  const enabledScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, focalPoint, chart);\n\n  each(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(zoomOptions.onZoom, [{chart}]);\n}\n\nfunction getRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\n\nfunction zoomRect(chart, p0, p1, transition = 'none') {\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n  const {mode = 'xy'} = zoomOptions;\n\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n\n  each(chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      updateRange(scale, getRange(scale, p0.x, p1.x), limits, true);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      updateRange(scale, getRange(scale, p0.y, p1.y), limits, true);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(zoomOptions.onZoom, [{chart}]);\n}\n\nfunction zoomScale(chart, scaleId, range, transition = 'none') {\n  storeOriginalScaleLimits(chart, getState(chart));\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n}\n\nfunction resetZoom(chart, transition = 'default') {\n  const state = getState(chart);\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state);\n\n  each(chart.scales, function(scale) {\n    const scaleOptions = scale.options;\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n  });\n  chart.update(transition);\n  callback(state.options.zoom.onZoomComplete, [{chart}]);\n}\n\nfunction getOriginalRange(state, scaleId) {\n  const original = state.originalScaleLimits[scaleId];\n  if (!original) {\n    return;\n  }\n  const {min, max} = original;\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\n}\n\nfunction getZoomLevel(chart) {\n  const state = getState(chart);\n  let min = 1;\n  let max = 1;\n  each(chart.scales, function(scale) {\n    const origRange = getOriginalRange(state, scale.id);\n    if (origRange) {\n      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\n\nfunction panScale(scale, delta, limits, state) {\n  const {panDelta} = state;\n  // Add possible cumulative delta from previous pan attempts where scale did not change\n  const storedDelta = panDelta[scale.id] || 0;\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n  const fn = panFunctions[scale.type] || panFunctions.default;\n  if (callback(fn, [scale, delta, limits])) {\n    // The scale changed, reset cumulative delta\n    panDelta[scale.id] = 0;\n  } else {\n    // The scale did not change, store cumulative delta\n    panDelta[scale.id] = delta;\n  }\n}\n\nfunction pan(chart, delta, enabledScales, transition = 'none') {\n  const {x = 0, y = 0} = typeof delta === 'number' ? {x: delta, y: delta} : delta;\n  const state = getState(chart);\n  const {options: {pan: panOptions, limits}} = state;\n  const {mode = 'xy', onPan} = panOptions || {};\n\n  storeOriginalScaleLimits(chart, state);\n\n  const xEnabled = x !== 0 && directionEnabled(mode, 'x', chart);\n  const yEnabled = y !== 0 && directionEnabled(mode, 'y', chart);\n\n  each(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(onPan, [{chart}]);\n}\n\nfunction getInitialScaleBounds(chart) {\n  const state = getState(chart);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min, max} = state.originalScaleLimits[scaleId] || {min: {}, max: {}};\n    scaleBounds[scaleId] = {min: min.scale, max: max.scale};\n  }\n\n  return scaleBounds;\n}\n\nfunction isZoomedOrPanned(chart) {\n  const scaleBounds = getInitialScaleBounds(chart);\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min: originalMin, max: originalMax} = scaleBounds[scaleId];\n\n    if (chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n\n    if (chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction removeHandler(chart, type) {\n  const {handlers} = getState(chart);\n  const handler = handlers[type];\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\n\nfunction addHandler(chart, target, type, handler) {\n  const {handlers, options} = getState(chart);\n  removeHandler(chart, type);\n  handlers[type] = (event) => handler(chart, event, options);\n  handlers[type].target = target;\n  target.addEventListener(type, handlers[type]);\n}\n\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\n\nfunction zoomStart(chart, event, zoomOptions) {\n  const {onZoomStart, onZoomRejected} = zoomOptions;\n  if (onZoomStart) {\n    const {left: offsetX, top: offsetY} = event.target.getBoundingClientRect();\n    const point = {\n      x: event.clientX - offsetX,\n      y: event.clientY - offsetY\n    };\n    if (callback(onZoomStart, [{chart, event, point}]) === false) {\n      callback(onZoomRejected, [{chart, event}]);\n      return false;\n    }\n  }\n}\n\nfunction mouseDown(chart, event) {\n  const state = getState(chart);\n  const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n  if (keyPressed(getModifierKey(panOptions), event) || keyNotPressed(getModifierKey(zoomOptions.drag), event)) {\n    return callback(zoomOptions.onZoomRejected, [{chart, event}]);\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  state.dragStart = event;\n\n  addHandler(chart, chart.canvas, 'mousemove', mouseMove);\n}\n\nfunction computeDragRect(chart, mode, beginPoint, endPoint) {\n  const {left: offsetX, top: offsetY} = beginPoint.target.getBoundingClientRect();\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  let {top, left, right, bottom, width: chartWidth, height: chartHeight} = chart.chartArea;\n\n  if (xEnabled) {\n    left = Math.min(beginPoint.clientX, endPoint.clientX) - offsetX;\n    right = Math.max(beginPoint.clientX, endPoint.clientX) - offsetX;\n  }\n\n  if (yEnabled) {\n    top = Math.min(beginPoint.clientY, endPoint.clientY) - offsetY;\n    bottom = Math.max(beginPoint.clientY, endPoint.clientY) - offsetY;\n  }\n  const width = right - left;\n  const height = bottom - top;\n\n  return {\n    left,\n    top,\n    right,\n    bottom,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + ((chartWidth - width) / chartWidth) : 1,\n    zoomY: yEnabled && height ? 1 + ((chartHeight - height) / chartHeight) : 1\n  };\n}\n\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart) {\n    return;\n  }\n\n  removeHandler(chart, 'mousemove');\n  const {mode, onZoomComplete, drag: {threshold = 0}} = state.options.zoom;\n  const rect = computeDragRect(chart, mode, state.dragStart, event);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n  // Remove drag start and end before chart update to stop drawing selected area\n  state.dragStart = state.dragEnd = null;\n\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n\n  zoomRect(chart, {x: rect.left, y: rect.top}, {x: rect.right, y: rect.bottom}, 'zoom');\n\n  setTimeout(() => (state.dragging = false), 500);\n  callback(onZoomComplete, [{chart}]);\n}\n\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  // Before preventDefault, check if the modifier key required and pressed\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    callback(zoomOptions.onZoomRejected, [{chart, event}]);\n    return;\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n\n  // Prevent the event from triggering the default behavior (eg. Content scrolling).\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n\n  // Firefox always fires the wheel event twice:\n  // First without the delta and right after that once with the delta properties.\n  if (event.deltaY === undefined) {\n    return;\n  }\n  return true;\n}\n\nfunction wheel(chart, event) {\n  const {handlers: {onZoomComplete}, options: {zoom: zoomOptions}} = getState(chart);\n\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n\n  const rect = event.target.getBoundingClientRect();\n  const speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);\n  const amount = {\n    x: speed,\n    y: speed,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n\n  zoom(chart, amount);\n\n  if (onZoomComplete) {\n    onZoomComplete();\n  }\n}\n\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => callback(handler, [{chart}]), delay);\n  }\n}\n\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {wheel: wheelOptions, drag: dragOptions, onZoomComplete} = options.zoom;\n\n  // Install listeners. Do this dynamically based on options so that we can turn zoom on and off\n  // We also want to make sure listeners aren't always on. E.g. if you're scrolling down a page\n  // and the mouse goes over a chart you don't want it intercepted unless the plugin is enabled\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n  }\n}\n\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n}\n\nfunction createEnabler(chart, state) {\n  return function(recognizer, event) {\n    const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n    const srcEvent = event && event.srcEvent;\n    if (!srcEvent) { // Sometimes Hammer queries this with a null event.\n      return true;\n    }\n    if (!state.panning && event.pointerType === 'mouse' && (\n      keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))\n    ) {\n      callback(panOptions.onPanRejected, [{chart, event}]);\n      return false;\n    }\n    return true;\n  };\n}\n\nfunction pinchAxes(p0, p1) {\n  // fingers position difference\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY);\n\n  // diagonal fingers will change both (xy) axes\n  const p = pinchX / pinchY;\n  let x, y;\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n  return {x, y};\n}\n\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {center, pointers} = e;\n    // Hammer reports the total scaling. We need the incremental amount\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n\n    zoom(chart, amount);\n\n    // Keep track of overall scale\n    state.scale = e.scale;\n  }\n}\n\nfunction startPinch(chart, state) {\n  if (state.options.zoom.pinch.enabled) {\n    state.scale = 1;\n  }\n}\n\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null; // reset\n    callback(state.options.zoom.onZoomComplete, [{chart}]);\n  }\n}\n\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n  if (delta) {\n    state.panning = true;\n    pan(chart, {x: e.deltaX - delta.x, y: e.deltaY - delta.y}, state.panScales);\n    state.delta = {x: e.deltaX, y: e.deltaY};\n  }\n}\n\nfunction startPan(chart, state, event) {\n  const {enabled, overScaleMode, onPanStart, onPanRejected} = state.options.pan;\n  if (!enabled) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n\n  if (callback(onPanStart, [{chart, event, point}]) === false) {\n    return callback(onPanRejected, [{chart, event}]);\n  }\n\n  state.panScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, point, chart);\n  state.delta = {x: 0, y: 0};\n  clearTimeout(state.panEndTimeout);\n  handlePan(chart, state, event);\n}\n\nfunction endPan(chart, state) {\n  state.delta = null;\n  if (state.panning) {\n    state.panEndTimeout = setTimeout(() => (state.panning = false), 500);\n    callback(state.options.pan.onPanComplete, [{chart}]);\n  }\n}\n\nconst hammers = new WeakMap();\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {pan: panOptions, zoom: zoomOptions} = options;\n\n  const mc = new Hammer.Manager(canvas);\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', () => startPinch(chart, state));\n    mc.on('pinch', (e) => handlePinch(chart, state, e));\n    mc.on('pinchend', (e) => endPinch(chart, state, e));\n  }\n\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', (e) => startPan(chart, state, e));\n    mc.on('panmove', (e) => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n\n  hammers.set(chart, mc);\n}\n\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\n\nvar version = \"1.2.0\";\n\nvar plugin = {\n  id: 'zoom',\n\n  version,\n\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null,\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy',\n    }\n  },\n\n  start: function(chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n    chart.resetZoom = (transition) => resetZoom(chart, transition);\n    chart.getZoomLevel = () => getZoomLevel(chart);\n    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);\n    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);\n  },\n\n  beforeEvent(chart) {\n    const state = getState(chart);\n    if (state.panning || state.dragging) {\n      // cancel any event handling while panning or dragging\n      return false;\n    }\n  },\n\n  beforeUpdate: function(chart, args, options) {\n    const state = getState(chart);\n    state.options = options;\n    addListeners(chart, options);\n  },\n\n  beforeDatasetsDraw: function(chart, args, options) {\n    const {dragStart, dragEnd} = getState(chart);\n\n    if (dragEnd) {\n      const {left, top, width, height} = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd);\n\n      const dragOptions = options.zoom.drag;\n      const ctx = chart.ctx;\n\n      ctx.save();\n      ctx.beginPath();\n      ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n      ctx.fillRect(left, top, width, height);\n\n      if (dragOptions.borderWidth > 0) {\n        ctx.lineWidth = dragOptions.borderWidth;\n        ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n        ctx.strokeRect(left, top, width, height);\n      }\n      ctx.restore();\n    }\n  },\n\n  stop: function(chart) {\n    removeListeners(chart);\n\n    if (Hammer) {\n      stopHammer(chart);\n    }\n    removeState(chart);\n  },\n\n  panFunctions,\n\n  zoomFunctions\n};\n\nexport { plugin as default, pan, resetZoom, zoom, zoomScale };\n"]},"metadata":{},"sourceType":"module"}